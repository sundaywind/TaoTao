1.哪个行业赚钱多？
	✔电商行业：
		1）互联网行业的项目中尽可能减少关联查询（并发量大的）。使用冗余来解决表单的关联关系。也有利于分库分表。
		2）条形码、二维码原理：
			扫的时候会触发一个事件，走js会转换为一串数字，数字在数据库里存的商品的信息价格，然后回返。
		3）SKU：
			最小库存量单位。【同一款商品划分出不同的配置。一个SKU对应一款商品的颜色配置都已固定。例：一款手机 有土豪金有黑色、内存有16G 32G 64G，一个黑色64G就是一个SKU】
	✖传统行业：
	
2.电商行业特点：
	1）技术新
	2）技术范围广
	3）分布式
	4）高并发、集群、负载均衡、高可用
	5）海量数据
	6）业务复杂
	7）系统安全

3.电商行业模式：
	B2B：企业到企业，商家到商家。代表：阿里巴巴、慧聪网
	B2C：商家到客户。代表：淘淘商城、京东、淘宝商城（B2B2C）
	C2C：客户到客户。代表：闲鱼
	O2O：线上到线下。代表：实体店商家注册到网上网店
	
4.大纲：
	1）项目工程搭建，框架整合。
	2）后台管理：后台商品分类的展示、分页插件、商品添加、商品类目的选择、图片上传、富文本编辑器、商品规格的实现。
	3）前台系统：搭建、首页商品分类的展示、Jsonp、前台大广告位的展示、商品详情页面的展示、购物车订单系统的实现。
	4）cms系统的实现。
	5）系统添加缓存、Redis、缓存同步。
	6）搜索功能的实现，使用solr实现搜索。
	7）单点登录系统。Session共享。
	8）Nginx，反向代理工具。
	9）Redis集群的搭建、solr集群的搭建。
	10）系统的部署。

5.商城功能（需求）
	会员 可以在商城浏览商品、下订单、以及参加各种活动。
	管理员、运营 可以在平台后台管理系统中管理商品、订单、会员等。
	客服 可以在后台管理系统中处理用户的询问以及投诉。
	
6.一个系统必须有前台（类似现在所有项目），不一定有后台。
	没后台弊端：若前台需要什么功能必须工程师动手，非常不方便。
	有后台管理系统：让不懂技术的也可以操作。（CMS）
	
7.传统项目有什么问题？
	1）模块之间耦合度太高，其中一个升级其他都得升级。
	2）开发困难，各个团队开发最后都要整合一起。
	3）系统的扩展性差。
	4）不能灵活的进行分布式部署。
	✔解决方法-（使用分布式：把系统拆分成多个工程，要完成系统的工程需要多个工程协作完成。这种形式叫做分布式）【使用分布式的架构必须使用Maven工程】
		优点：
			把模块拆分成独立的工程，单点运行。如果某一个点压力大可以对这一个点单独增加配置。其他的点不受影响。
		缺点：
			系统之间交互需要额外的工作量来进行接口的开发。
		
8.技术选型（主要技术）
	Spring、SpringMVC、MyBatis
	JSP、JSTL、jQuery、jQuery plugin、EasyUI、KindEditor（富文本编辑器）、CSS+DIV
	Redis（缓存服务器）
	Solr（搜索）
	httpclient（调用系统服务）
	MySQL
	Nginx（web反向代理服务器）
	
9.后台管理系统工程搭建：
	1）父工程的搭建：父工程是一个pom工程。在父工程中定义规定依赖的jar包的版本信息、插件的版本号。（<dependencyManagement><pluginManagement>不实际依赖，只定义版本）
	2）通用工具类工程：pom.xml Copy父工程中，项目中通用的jar包。
	3）后台管理工程：pom.xml 依赖common工程。要运行工程，需要运行聚合工程也就是taotao-manager，在pom文件中添加Tomcat插件。
	4）pojo：不需要依赖任何。
	5）mapper：要依赖pojo，MyBatis，MySQL，连接池。
	6）service：需要依赖mapper，牵扯到事务 还需要依赖Spring。
	7）web：需要依赖service，跟前端相关的依赖（JSP相关、文件上传组件）

10.项目结构：
	parent			（pom聚合工程）
		common		（jar工程）
		manager		（pom父工程）
			pojo	（jar工程）
			mapper	（jar工程）
			service	（jar工程）
			web		（war工程）*工程中必须有一个war包。

11.启动工程：
	使用maven命令：clean tomcat7:run（tomcat7指定使用tomcat7的插件）
	注意：
		1、需要把taotao-parent工程安装到本地仓库。（Install）
		2、需要把taotao-common安装到本地仓库。

12.框架整合思路：
	Dao层：
		使用MyBatis框架。创建一个mybatis-config.xml（sqlMapConfig.xml）配置文件。
		创建Spring的配置文件：applicationContext-dao.xml配置文件：
			1）配置数据源。
			2）需要让Spring容器管理SqlSessionFactory，单利的存在。
			3）把mapper的代理对象放到Spring容器中，使用包扫描的方式，来加载mapper的代理对象放到Spring中。
	Service层：
		事务管理。
		把Service实现类对象放到Spring容器中。
	Web表现层：
		配置注解驱动。
		配置视图解析器。
		扫描Controller。
	web.xml
		Spring的配置。
		SpringMVC前端控制器的配置。
		post乱码过滤器。	
	这么多配置文件应该放到哪里？
		pom包、jar包，都不能被其他地方引用（/WEB-INF/lib目录）。
		项目最后要打成一个war包，所以配置文件放在war项目中。

12.Spring和SpringMVC父子容器的关系：
	Spring容器【Service+Dao】
	SpringMVC容器【Controller】（是Spring容器的子容器）
	===子容器可以访问父容器，而父容器不能访问子容器===
	如果都放到Spring容器中，springmvc.xml中就不做Controller包的扫描，结果呢？
		请求的时候会发现一个Controller都没有，组件加载的时候会发现没有处理器，处理器的映射关系会建立不起来，必须把Controller放入到自己的SpringMVC容器中才能运行。
		但可以把Service、Dao、Controller都扫描到SpringMVC容器中。但为了扩展不建议这么干！
		事务必须配置到Spring容器，事务管理器不能访问Controller。
		
13.测试整合结果：
	需求：根据商品ID，查询商品信息。
						
14.商品列表实现 需要：
	1）创建数据库。
	2）使用MyBatis的逆向工程生成代码。
	3）框架整合。（SpringMVC+Spring+MyBatis）
	4）商品列表的实现。

15.MyBatis的PageHelper分页插件：
	1）使用：
		第一步：引入pageHelper的jar包。
		第二步：需要在SqlMapConfig.xml中配置插件。
			<?xml version="1.0" encoding="UTF-8" ?>
			<!DOCTYPE configuration
					PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
					"http://mybatis.org/dtd/mybatis-3-config.dtd">
			<configuration>
				<!-- 配置分页插件 -->
				<plugins>
					<plugin interceptor="com.github.pagehelper.PageHelper">
						<!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库-->        
			        	<property name="dialect" value="mysql"/>
					</plugin>
				</plugins>
			</configuration>
		第三步：在查询的sql语句执行之前，添加一行代码：
			PageHelper.startPage(1, 10);
			第一个参数是page，要显示第几页。
			第二个参数是rows，没页显示的记录数。
		第四步：取查询结果的总数量。
			创建一个PageInfo类的对象，从对象中取分页信息。
	2）测试：
		public class TestPageHelper {
			@Test
			public void testPageHelper() {
				// 创建一个spring容器
				@SuppressWarnings("resource")
				ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-*.xml");
				// 从spring容器中获得Mapper的代理对象
				TbItemMapper mapper = applicationContext.getBean(TbItemMapper.class);
				// 执行查询，并分页
				TbItemExample example = new TbItemExample();
				// 分页处理
				PageHelper.startPage(2, 10); // 参数是：当前页，每页显示的条数
				List<TbItem> list = mapper.selectByExample(example);
				// 取商品列表
				for (TbItem tbItem : list) {
					System.out.println(tbItem.getTitle());
				}
				// 取分页信息
				PageInfo<TbItem> pageInfo = new PageInfo<>(list);
				long total = pageInfo.getTotal();
				System.out.println("共有商品：" + total);
			}
		}



		

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
